<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title></title>
    <style>
        body { margin: 0; }
    </style>
    <link rel="stylesheet" href="css/dat.gui.css">
    <script src="3d/dat.gui.js"></script>
    <script src="gsap/gsap.min.js"></script>
</head>
<body>
<canvas id="canvas" class="c2d" width="1000" height="500"></canvas>
</body>
<script type="module">
    import * as THREE from './3d/three.module.js';
    import { OrbitControls }  from './3d/OrbitControls.js'
    import { GLTFLoader }  from './loaders/GLTFLoader.js';
    import { RGBELoader } from './loaders/RGBELoader.js';
    import DynamicEnv from './config/DynamicEnv.js'

    //********************************↓COMMON↓***************************************
    const canvas = document.querySelector('#canvas')
    canvas.height = window.innerHeight
    canvas.width = window.innerWidth

    let scene,camera,renderer,controls,dynamicEnv

    const fov = 75
    const aspect =  window.innerWidth/  window.innerHeight
    const near = 0.1
    const far = 500

    const gltfLoader = new GLTFLoader()
    let envmap1, envmap2,groundLoader,cubeRenderTarget, cubeCamera,time = 0

    scene = new THREE.Scene()
    scene.background = new THREE.Color('black')
    scene.fog = new THREE.Fog( 0x000000, 4, 40 );

    camera = new THREE.PerspectiveCamera(fov, aspect, near, far)
    camera.position.set( -0.1072,  1, -3.4973);
    camera.uIntensity = 0

    renderer = new THREE.WebGLRenderer({ canvas,antialias: true })
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setAnimationLoop(renderLoop);
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1;

    // 控制相机
    controls = new OrbitControls(camera, canvas)


    window.addEventListener('resize', onWindowResized);

    function onWindowResized() {
        renderer.setSize(window.innerWidth, window.innerHeight);

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

    }

    function renderLoop(){
        if (groundLoader){
            groundLoader.visible = false;
            cubeCamera.position.copy(camera.position);
            cubeCamera.position.y *= -1;
            cubeCamera.update(renderer,scene);
            groundLoader.visible = true;
        }
        renderer.render( scene, camera );

        time += 0.01
        const step = time > 1 ? 1 : time
        if (dynamicEnv && step < 1){
            dynamicEnv.setWeight(step);
            dynamicEnv.setIntensity(step);
        }

    }
    //********************************↑COMMON↑***************************************

    cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024);
    cubeRenderTarget.texture.type = THREE.UnsignedByteType;
    cubeCamera = new THREE.CubeCamera(0.1, 200, cubeRenderTarget);

    gltfLoader.load('./models/gltf/su7-car_edit.glb',(gltf)=>{
        gltf.scene.traverse((child)=>{
            if (child.name === '平面'){
                // child.material.envMap = cubeRenderTarget.texture;
                // child.castShadow = true;
                // child.receiveShadow = true;
                groundLoader = child
            }

            if (child.type === 'Mesh'){
                // child.material.envMap = cubeRenderTarget.texture;
                // child.material.envMapIntensity = 10;
                child.castShadow = true;
                child.receiveShadow = true;
            }
        })

        scene.add(gltf.scene)
    })

    init()
    async function init(){
        envmap1 = await getRGBELoader('./models/t_env_night.hdr')
        envmap2 = await getRGBELoader('./models/t_env_light.hdr')

        dynamicEnv = new DynamicEnv(renderer,{
            envmap1,
            envmap2,
        });
        // scene.background = dynamicEnv.envMap;
        scene.environment = dynamicEnv.envMap;

        gsap.to(camera,{
            fov: 50,
            uIntensity: 1,
            duration: 3,
            ease: 'power2.out',
            onUpdate:()=>{
                camera.updateProjectionMatrix();
            }
        })
    }

    function getRGBELoader(path){
        const rgbeLoader = new RGBELoader()

        return new Promise(resolve => {
            rgbeLoader.load(path, (reb) =>{
                reb.mapping = THREE.CubeUVReflectionMapping;
                resolve(reb)
            })
        })
    }






</script>
</html>
