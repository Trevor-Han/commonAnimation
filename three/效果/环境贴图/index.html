<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title></title>
    <style>
        body { margin: 0; }
    </style>
    <link rel="stylesheet" href="../../css/dat.gui.css">
    <script src="../../3d/dat.gui.js"></script>
    <script src="../../su7/js/gsap/gsap.min.js"></script>
</head>
<body>
<canvas id="canvas" class="c2d" width="1000" height="500"></canvas>
</body>
<script type="module">
    import * as THREE from '../../3d/three.module.js';
    import { OrbitControls }  from '../../3d/OrbitControls.js'
    import { GLTFLoader }  from '../../loaders/GLTFLoader.js';
    import { RGBELoader } from '../../loaders/RGBELoader.js';
    import DynamicEnv from  '../../su7/js/config/DynamicEnv.js'
    import ReflectFloorMesh from '../../su7/js/config/ReflectFloor.js'
    import { vertexShader as vertexWind} from "../../su7/js/shaders/wind/vertex_line.js";
    import {fragmentShader as fragmentWind} from "../../su7/js/shaders/wind/fragment_line_wind.js";
    // import { vertexShader as reflecFloorVertexShader} from "../../su7/js/shaders/ReflecFloor/vert.js";
    // import {fragmentShader as reflecFloorFragmentShader} from "../../su7/js/shaders/ReflecFloor/frag.js";

    //********************************↓COMMON↓***************************************
    const canvas = document.querySelector('#canvas')
    canvas.height = window.innerHeight
    canvas.width = window.innerWidth

    let scene,camera,renderer,controls,dynamicEnv, windLine = {}

    const fov = 75
    const aspect =  window.innerWidth/  window.innerHeight
    const near = 0.1
    const far = 500

    const gltfLoader = new GLTFLoader()
    let envmap1, envmap2,groundLoader,cubeRenderTarget, cubeCamera,time = 0

    scene = new THREE.Scene()
    scene.background = new THREE.Color('black')
    scene.fog = new THREE.Fog( 0x000000, 4, 40 );

    camera = new THREE.PerspectiveCamera(fov, aspect, near, far)
    camera.position.set( -0.1072,  1, -3.4973);
    camera.uIntensity = 0

    renderer = new THREE.WebGLRenderer({ canvas,antialias: true })
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setAnimationLoop(renderLoop);
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1;

    // 控制相机
    controls = new OrbitControls(camera, canvas)


    window.addEventListener('resize', onWindowResized);

    function onWindowResized() {
        renderer.setSize(window.innerWidth, window.innerHeight);

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

    }

    let clock = new THREE.Clock();
    function renderLoop(){
        if (groundLoader){
            groundLoader.visible = false;
            cubeCamera.position.copy(camera.position);
            cubeCamera.position.y *= -1;
            cubeCamera.update(renderer,scene);
            groundLoader.visible = true;
        }
        if (windLine['wind_line_1'] && windLine['wind_line_2'] && windLine['wind_line_3'] && windLine['wind_line_4'] && windLine['wind_line_5'] ){
            windLine['wind_line_1'].material.uniforms.vTime.value = clock.getElapsedTime()
            windLine['wind_line_2'].material.uniforms.vTime.value = clock.getElapsedTime()
            windLine['wind_line_3'].material.uniforms.vTime.value = clock.getElapsedTime()
            windLine['wind_line_4'].material.uniforms.vTime.value = clock.getElapsedTime()
            windLine['wind_line_5'].material.uniforms.vTime.value = clock.getElapsedTime()
        }
        renderer.render( scene, camera );
        // time += 0.01
        // const step = time > 1 ? 1 : time
        // if (envmap1 && envmap2 && step < 1){
        //     const dynamicEnv = new DynamicEnv(renderer,{
        //         envmap1,
        //         envmap2,
        //     });
        //     scene.environment = dynamicEnv.envMap;
        //     dynamicEnv.setWeight(step);
        //     dynamicEnv.setIntensity(step);
        // }

    }
    //********************************↑COMMON↑***************************************

    cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024);
    cubeRenderTarget.texture.type = THREE.UnsignedByteType;
    cubeCamera = new THREE.CubeCamera(0.1, 200, cubeRenderTarget);

    gltfLoader.load('../../su7/models/gltf/su7-car_edit.glb',(gltf)=>{
        gltf.scene.traverse((child)=>{
            if (child.name === '平面'){
                child.material.normalMap = new THREE.TextureLoader().load('../../su7/img/t_floor_normal.webp')
                child.material.roughnessMap = new THREE.TextureLoader().load('../../su7/img/t_floor_roughness.webp')
                // child.material.envMap = cubeRenderTarget.texture;
                // child.castShadow = true;
                // child.receiveShadow = true;
                child.visible = false
                groundLoader = child
            }

            if (child.type === 'Mesh'){
                // child.material.envMap = cubeRenderTarget.texture;
                // child.material.envMapIntensity = 10;
                child.castShadow = true;
                child.receiveShadow = true;
            }
        })

        scene.add(gltf.scene)
    })

    gltfLoader.load('../../su7/models/gltf/wind_line.glb',(gltf)=>{
        gltf.scene.traverse((child)=>{
            if (child.isMesh){
                // console.log(child.name);
                windLine[child.name] = child
                child.material = new THREE.ShaderMaterial({
                    extensions: {
                        derivatives: '#extension GL_OES_standard_derivatives : enable'
                    },
                    side: THREE.DoubleSide,
                    uniforms: {
                        vTime: { type: 'f', value: 0 },
                        color: { value: new THREE.Color(1, 0, 0.13, 1) },
                        vProgress: { type: 'f', value: 0.8 },
                        opacity:{type:'f',value:1},
                        random:{value:Math.random()}
                    },
                    transparent: true,
                    // depthTest: false,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    vertexShader: vertexWind,
                    fragmentShader: fragmentWind

                })
            }
        })
        // console.log(windLine);
        scene.add(gltf.scene)
    })

    init()
    initReflector()
    async function init(){
        envmap1 = await getRGBELoader('../../su7/models/t_env_night.hdr')
        envmap2 = await getRGBELoader('../../su7/models/t_env_light.hdr')
        envmap2.mapping = THREE.EquirectangularReflectionMapping
        scene.environment = envmap2

        // dynamicEnv = new DynamicEnv(renderer,{
        //     envmap1,
        //     envmap2,
        // });
        // scene.environment = dynamicEnv.envMap;

        gsap.to(camera,{
            fov: 50,
            uIntensity: 1,
            duration: 3,
            ease: 'power2.out',
            onUpdate:()=>{
                camera.updateProjectionMatrix();
            }
        })
    }

    function initReflector() {
        let geo = new THREE.PlaneGeometry(64, 64)
        let floor = new ReflectFloorMesh(geo, {
            textureWidth: 512,
            textureHeight: 512,
            normalMap0: new THREE.TextureLoader().load('../../su7/img/t_floor_normal.webp'),
            roughness: new THREE.TextureLoader().load('../../su7/img/t_floor_roughness.webp'),
            tNoise: new THREE.TextureLoader().load('../../su7/img/noise.png')
        })
        floor.rotation.x = - Math.PI / 2;
        floor.position.y = 0.001;
        scene.add(floor)
    }

    function getRGBELoader(path){
        const rgbeLoader = new RGBELoader()

        return new Promise(resolve => {
            rgbeLoader.load(path, (reb) =>{
                reb.mapping = THREE.CubeUVReflectionMapping;
                resolve(reb)
            })
        })
    }






</script>
</html>
