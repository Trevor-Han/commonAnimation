<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title></title>
    <style>
        body { margin: 0; }
    </style>
    <link rel="stylesheet" href="../../css/dat.gui.css">
    <script src="../../3d/dat.gui.js"></script>
</head>
<body>
<canvas id="canvas" class="c2d" width="1000" height="500"></canvas>
</body>
<script type="module">
    import * as THREE from '../../3d/three.module.js';
    import { OrbitControls }  from '../../3d/OrbitControls.js'
    // import line from '../../utils/output_file.json'
    import {vertexShader} from '../../su7/js/shaders/line/vertex_line.js'
    import {fragmentShader} from '../../su7/js/shaders/line/fragment_line.js'


    //********************************↓COMMON↓***************************************
    const canvas = document.querySelector('#canvas')
    canvas.height = window.innerHeight
    canvas.width = window.innerWidth

    let scene,camera,renderer,controls

    const fov = 40
    const aspect =  window.innerWidth/  window.innerHeight
    const near = 0.1
    const far = 1000

    scene = new THREE.Scene()
    scene.background = new THREE.Color('#232323')

    camera = new THREE.PerspectiveCamera(fov, aspect, near, far)
    camera.position.set(0, 10, 15)
    camera.lookAt(10,10, 10)

    renderer = new THREE.WebGLRenderer({ canvas })
    renderer.setAnimationLoop(renderLoop);
    renderer.shadowMap.enabled = true;

    // 控制相机
    controls = new OrbitControls(camera, canvas)


    window.addEventListener('resize', onWindowResized);

    function onWindowResized() {
        renderer.setSize(window.innerWidth, window.innerHeight);

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

    }

    function renderLoop(){
        for (let i= 0; i<allLinesMesh.length;i++){
            allLinesMesh[i].material.uniforms.vTime.value = clock.getElapsedTime()
            console.log(allLinesMesh[i].material.uniforms.vTime.value);
        }
        renderer.render( scene, camera );
    }

    //********************************↑COMMON↑***************************************
    const group = new THREE.Group()
    const allLinesMesh = []
    const clock = new THREE.Clock()
    const material = new THREE.ShaderMaterial({
        extensions: {
            derivatives: "#extension GL_OES_standard_derivatives : enable"
        },
        side: THREE.DoubleSide,
        uniforms: {
            vTime: { type: "f", value: 0 },
            color: { value: new THREE.Color(0.2, 0.8, 1, 1) },
            vProgress: { type: "f", value: 0.8 },
            uSize: { type: "f", value: 7 }
        },
        transparent: true,
        // depthTest: false,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader
    });

    fetch('../../utils/output_file.json').then(response => response.json())
        .then(data => {
            const curves = []
            let radius = 0.005
            let radialSegments = 3
            data.points.forEach(path=>{
                let pointList = []
                for (let i = 0; i < path.length; i++) {
                    pointList.push(
                        new THREE.Vector3(
                            path[i].x,
                            path[i].y,
                            path[i].z
                        )
                    )
                }
                let tempCurve = new THREE.CatmullRomCurve3(pointList)
                curves.push(tempCurve)
            })
            curves.forEach(path=>{
                const geometry = new THREE.TubeGeometry(path, 32, radius, radialSegments, false);
                let line = new THREE.Mesh(geometry, material);
                group.scale.set(2, 2, 2)
                group.position.y = 0.2
                // line.scale.set(0.1, 0.1, 0.1)
                group.add(line);
                allLinesMesh.push(line)
            })
            scene.add(group)

        })

    const planeMesh = new THREE.Mesh(new THREE.BufferGeometry(10,10,10), new THREE.MeshBasicMaterial({
        side: THREE.DoubleSide,
        color: '#80deea',
        // stencilWrite: true,
        stencilFunc: THREE.NotEqualStencilFunc,
        stencilFail: THREE.ZeroStencilOp,
        stencilZFail: THREE.ZeroStencilOp,
        stencilZPass: THREE.ZeroStencilOp,
    }));
    // planeMesh.scale.setScalar(1.5);
    planeMesh.material.color.set('#80deea').convertLinearToSRGB();
    // planeMesh.renderOrder = 2;
    scene.add(planeMesh);

</script>
</html>
