<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title></title>
    <style>
        body { margin: 0; }
    </style>
    <link rel="stylesheet" href="../../css/dat.gui.css">
    <script src="../../3d/dat.gui.js"></script>
</head>
<body>
<canvas id="canvas" class="c2d" width="1000" height="500"></canvas>
</body>
<script type="module">
    import * as THREE from '../../3d/three.module.js';
    import { OrbitControls }  from '../../3d/OrbitControls.js'

    //********************************↓COMMON↓***************************************
    const canvas = document.querySelector('#canvas')
    canvas.height = window.innerHeight
    canvas.width = window.innerWidth

    let scene,camera,renderer,controls,material

    const fov = 40
    const aspect =  window.innerWidth/  window.innerHeight
    const near = 0.1
    const far = 1000

    scene = new THREE.Scene()
    scene.background = new THREE.Color('#232323')

    camera = new THREE.PerspectiveCamera(fov, aspect, near, far)
    camera.position.set(0, 10, 15)
    camera.lookAt(10,10, 10)

    renderer = new THREE.WebGLRenderer({ canvas,antialias: true })
    renderer.setAnimationLoop(renderLoop);
    renderer.shadowMap.enabled = true;
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize( window.innerWidth, window.innerHeight );

    // 控制相机
    controls = new OrbitControls(camera, canvas)


    window.addEventListener('resize', onWindowResized);

    function onWindowResized() {
        renderer.setSize(window.innerWidth, window.innerHeight);

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

    }
    const clock = new THREE.Clock()
    function renderLoop(){
        waterMaterial.uniforms.uTime.value = clock.getElapsedTime()
        renderer.render( scene, camera );
    }

    //********************************↑COMMON↑***************************************
    const debugObject={
        depthColor: '#181818',
        surfaceColor: '#ffffff'
    }
    const gui = new GUI({width:314})
    const perlinClassic3D = `
    vec4 permute(vec4 x)
    {
        return mod(((x*34.0)+1.0)*x, 289.0);
    }
    vec4 taylorInvSqrt(vec4 r)
    {
        return 1.79284291400159 - 0.85373472095314 * r;
    }
    vec3 fade(vec3 t)
    {
        return t*t*t*(t*(t*6.0-15.0)+10.0);
    }

    float perlinClassic3D(vec3 P)
    {
        vec3 Pi0 = floor(P); // Integer part for indexing
        vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
        Pi0 = mod(Pi0, 289.0);
        Pi1 = mod(Pi1, 289.0);
        vec3 Pf0 = fract(P); // Fractional part for interpolation
        vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
        vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
        vec4 iy = vec4(Pi0.yy, Pi1.yy);
        vec4 iz0 = Pi0.zzzz;
        vec4 iz1 = Pi1.zzzz;

        vec4 ixy = permute(permute(ix) + iy);
        vec4 ixy0 = permute(ixy + iz0);
        vec4 ixy1 = permute(ixy + iz1);

        vec4 gx0 = ixy0 / 7.0;
        vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
        gx0 = fract(gx0);
        vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
        vec4 sz0 = step(gz0, vec4(0.0));
        gx0 -= sz0 * (step(0.0, gx0) - 0.5);
        gy0 -= sz0 * (step(0.0, gy0) - 0.5);

        vec4 gx1 = ixy1 / 7.0;
        vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
        gx1 = fract(gx1);
        vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
        vec4 sz1 = step(gz1, vec4(0.0));
        gx1 -= sz1 * (step(0.0, gx1) - 0.5);
        gy1 -= sz1 * (step(0.0, gy1) - 0.5);

        vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
        vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
        vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
        vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
        vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
        vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
        vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
        vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

        vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
        g000 *= norm0.x;
        g010 *= norm0.y;
        g100 *= norm0.z;
        g110 *= norm0.w;
        vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
        g001 *= norm1.x;
        g011 *= norm1.y;
        g101 *= norm1.z;
        g111 *= norm1.w;

        float n000 = dot(g000, Pf0);
        float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
        float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
        float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
        float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
        float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
        float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
        float n111 = dot(g111, Pf1);

        vec3 fade_xyz = fade(Pf0);
        vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
        vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
        float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
        return 2.2 * n_xyz;
    }`
    const waveElevation = `
    float waveElevation(vec3 position) {
    float elevation = sin(position.x * uBigWavesFrequency.x + uTime * uBigWavesSpeed) *
                      sin(position.z * uBigWavesFrequency.y + uTime * uBigWavesSpeed) *
                      uBigWavesElevation;

    for(float i = 1.0; i <= uSmallIterations; i++)
    {
        elevation -= abs(perlinClassic3D(vec3(position.xz * uSmallWavesFrequency * i, uTime * uSmallWavesSpeed)) * uSmallWavesElevation / i);
    }

    return elevation;
}`
    const pointLight = `
        vec3 pointLight(vec3 lightColor, float lightIntensity, vec3 normal, vec3 lightPosition, vec3 viewDirection, float specularPower, vec3 position, float lightDecay)
        {
            vec3 lightDelta = lightPosition - position;
            float lightDistance = length(lightDelta);
            vec3 lightDirection = normalize(lightDelta);
            vec3 lightReflection = reflect(- lightDirection, normal);

            // Shading
            float shading = dot(normal, lightDirection);
            shading = max(0.0, shading);

            // Specular
            float specular = - dot(lightReflection, viewDirection);
            specular = max(0.0, specular);
            specular = pow(specular, specularPower);

            // Decay
            float decay = 1.0 - lightDistance * lightDecay;
            decay = max(0.0, decay);

            return lightColor * lightIntensity * decay * (shading + specular);
        }
    `
    const vertex =
    `
    uniform float uTime;
    uniform float uBigWavesElevation;
    uniform float uBigWavesSpeed;
    uniform vec2 uBigWavesFrequency;

    uniform float uSmallWavesFrequency;
    uniform float uSmallWavesElevation;
    uniform float uSmallWavesSpeed;
    uniform float uSmallIterations;

    varying float vElevation;
    varying vec3 vNormal;
    varying vec3 vPosition;

    ${perlinClassic3D}
    ${waveElevation}

     void main(){
        float shift = 0.01;
        vec4 modelPosition = modelMatrix * vec4(position, 1.0);
        vec3 modelPositionA = modelPosition.xyz + vec3(shift, 0.0, 0.0);
        vec3 modelPositionB = modelPosition.xyz + vec3(0.0, 0.0, - shift);

        float elevation = waveElevation(modelPosition.xyz);
        modelPosition.y += elevation;
        modelPositionA.y += waveElevation(modelPositionA);
        modelPositionB.y += waveElevation(modelPositionB);

        vec3 toA = normalize(modelPositionA - modelPosition.xyz);
        vec3 toB = normalize(modelPositionB - modelPosition.xyz);
        vec3 computeNormal = cross(toA, toB);

        vec4 viewPosition = viewMatrix * modelPosition;
        vec4 projectedPosition = projectionMatrix * viewPosition;
        gl_Position = projectedPosition;

        vElevation = elevation;
        vNormal = computeNormal;
        vPosition = modelPosition.xyz;
     }
    `
    const fragment =
    `
    uniform vec3 uDepthColor;
    uniform vec3 uSurfaceColor;
    uniform float uColorOffset;
    uniform float uColorMultiplier;

    varying float vElevation;
    varying vec3 vNormal;
    varying vec3 vPosition;

    ${pointLight}

    void main(){
        vec3 viewDirection = normalize(vPosition - cameraPosition);
        vec3 normal = normalize(vNormal);

        float mixStrength = (vElevation + uColorOffset) * uColorMultiplier;
        mixStrength = smoothstep(0.0, 1.0, mixStrength);
        vec3 color = mix(uDepthColor, uSurfaceColor, mixStrength);

        vec3 light = vec3(0.0);
        light += pointLight(
            vec3(1.0),
            10.0,
            normal,
            vec3(0.0, 0.25, 0.0),
            viewDirection,
            30.0,
            vPosition,
            0.95
       );

        color *= light;

        gl_FragColor = vec4(color,1.0);
        #include <tonemapping_fragment>
        #include <colorspace_fragment>
    }
    `
    const waterGeometry = new THREE.PlaneGeometry(2, 2, 512, 512);
    waterGeometry.deleteAttribute("normal");
    waterGeometry.deleteAttribute("uv");

    const waterMaterial = new THREE.ShaderMaterial({
        side: THREE.DoubleSide,
        vertexShader: vertex,
        fragmentShader: fragment,
        uniforms: {
            uTime: { value: 0 },

            uBigWavesElevation: { value: 0.2 },
            uBigWavesFrequency: { value: new THREE.Vector2(4, 1.5) },
            uBigWavesSpeed:{ value: 1 },

            uSmallWavesFrequency: { value: 3 },
            uSmallWavesElevation: { value: 0.15 },
            uSmallWavesSpeed: { value: 0.2 },
            uSmallIterations: { value: 4 },

            uDepthColor: { value: new THREE.Color( debugObject.depthColor )},
            uSurfaceColor: { value: new THREE.Color( debugObject.surfaceColor )},

            uColorOffset: { value: 0.25 },
            uColorMultiplier: { value: 1 }
        }
    })

    const water = new THREE.Mesh(waterGeometry, waterMaterial);
    water.rotation.x = -Math.PI * 0.5;
    scene.add(water);

    gui.add(waterMaterial.uniforms.uBigWavesElevation,'value')
        .min(0)
        .max(1)
        .step(0.01)
        .name('海浪高度')
    gui.add(waterMaterial.uniforms.uBigWavesFrequency.value,'x')
        .min(0)
        .max(10)
        .step(0.01)
        .name('海浪频率X')
    gui.add(waterMaterial.uniforms.uBigWavesSpeed, "value")
        .min(0)
        .max(4)
        .step(0.001)
        .name("海浪速度");

    gui.add(waterMaterial.uniforms.uSmallWavesFrequency, "value")
        .min(0)
        .max(30)
        .step(0.001)
        .name("小波频次");
    gui.add(waterMaterial.uniforms.uSmallWavesSpeed, "value")
        .min(0)
        .max(4)
        .step(0.001)
        .name("小波速度");
    gui.add(waterMaterial.uniforms.uSmallIterations, "value")
        .min(0)
        .max(5)
        .step(1)
        .name("小波平滑迭代");
    gui.add(waterMaterial.uniforms.uSmallWavesElevation, "value")
        .min(0)
        .max(1)
        .step(0.001)
        .name("小波海拔");

    gui.add(waterMaterial.uniforms.uColorOffset, "value")
        .min(0)
        .max(1)
        .step(0.001)
        .name("颜色偏移");
    gui.add(waterMaterial.uniforms.uColorMultiplier, "value")
        .min(0)
        .max(10)
        .step(0.001)
        .name("uColorMultiplier");

    gui.addColor(debugObject, "depthColor").onChange(() => {
        waterMaterial.uniforms.uDepthColor.value.set(debugObject.depthColor);
    });
    gui.addColor(debugObject, "surfaceColor").onChange(() => {
        waterMaterial.uniforms.uSurfaceColor.value.set(debugObject.surfaceColor);
    });

</script>
</html>
