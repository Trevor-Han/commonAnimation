<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title></title>
    <style>
        body { margin: 0; }
    </style>
    <link rel="stylesheet" href="../../css/dat.gui.css">
    <script src="../../3d/dat.gui.js"></script>
</head>
<body>
<canvas id="canvas" class="c2d" width="1000" height="500"></canvas>
</body>
<script type="module">
    import * as THREE from '../../3d/three.module.js';
    import { OrbitControls }  from '../../3d/OrbitControls.js'

    //********************************↓COMMON↓***************************************
    const canvas = document.querySelector('#canvas')
    canvas.height = window.innerHeight
    canvas.width = window.innerWidth

    let scene,camera,renderer,controls,material

    const fov = 75
    const aspect =  window.innerWidth/  window.innerHeight
    const near = 0.01
    const far = 1000

    scene = new THREE.Scene()
    scene.background = new THREE.Color('#232323')

    camera = new THREE.PerspectiveCamera(fov, aspect, near, far)
    camera.position.set(0, 0, 4);
    camera.lookAt(new THREE.Vector3());

    renderer = new THREE.WebGLRenderer({ canvas,antialias: true })
    renderer.setAnimationLoop(renderLoop);
    renderer.shadowMap.enabled = true;
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize( window.innerWidth, window.innerHeight );

    // 控制相机
    controls = new OrbitControls(camera, canvas)


    window.addEventListener('resize', onWindowResized);

    function onWindowResized() {
        renderer.setSize(window.innerWidth, window.innerHeight);

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

    }
    const clock = new THREE.Clock()
    function renderLoop(){
        const time = clock.getElapsedTime();
        material.uniforms.uTime.value = time;
        particleMaterial.uniforms.uTime.value = time * 4;
        particles.rotation.y = time * 0.1;
        firefliesMaterial.uniforms.uTime.value = time;
        // mesh.rotation.y = clock.getElapsedTime();
        renderer.render( scene, camera );
    }

    //********************************↑COMMON↑***************************************

    // 顶点坐标 position、纹理坐标 uv、法线向量 normal都是顶点上的数据
    // uniform修饰符->全局变量，在顶点着色器和片元着色器都可以访问（每个顶点或像素数值都相同时变量使用）
    // attribute修饰符->局部变量，只能在顶点着色器中访问(加上，说明明这个数据是每个顶点上都不同的)
    // varying修饰符 -> 用来在顶点着色器和片元着色器之间传递变量的(顶点着色器里的变量想在片元着色器里使用)

    // 不同修饰符对应的变量所采用的命令方式，attribute 的用 a 开头如 aRadom，
    // uniform 的用 u 开头如 uTime，
    // varying 的用 v 开头如 vUv，这是比较直观的一种变量命名方式



    const vertexShader = /* GLSL */ `
      uniform float uTime;
      varying vec2 vUv;

     vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
    float permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}
    vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
    float taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}

    vec4 grad4(float j, vec4 ip){
      const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
      vec4 p,s;

      p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
      p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
      s = vec4(lessThan(p, vec4(0.0)));
      p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;

      return p;
    }

    float snoise(vec4 v){
      const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4
                            0.309016994374947451); // (sqrt(5) - 1)/4   F4
    // First corner
      vec4 i  = floor(v + dot(v, C.yyyy) );
      vec4 x0 = v -   i + dot(i, C.xxxx);

    // Other corners

    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
      vec4 i0;

      vec3 isX = step( x0.yzw, x0.xxx );
      vec3 isYZ = step( x0.zww, x0.yyz );
    //  i0.x = dot( isX, vec3( 1.0 ) );
      i0.x = isX.x + isX.y + isX.z;
      i0.yzw = 1.0 - isX;

    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );
      i0.y += isYZ.x + isYZ.y;
      i0.zw += 1.0 - isYZ.xy;

      i0.z += isYZ.z;
      i0.w += 1.0 - isYZ.z;

      // i0 now contains the unique values 0,1,2,3 in each channel
      vec4 i3 = clamp( i0, 0.0, 1.0 );
      vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
      vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );

      //  x0 = x0 - 0.0 + 0.0 * C
      vec4 x1 = x0 - i1 + 1.0 * C.xxxx;
      vec4 x2 = x0 - i2 + 2.0 * C.xxxx;
      vec4 x3 = x0 - i3 + 3.0 * C.xxxx;
      vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;

    // Permutations
      i = mod(i, 289.0);
      float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
      vec4 j1 = permute( permute( permute( permute (
                 i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
               + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
               + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
               + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));
    // Gradients
    // ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)
    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.

      vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;

      vec4 p0 = grad4(j0,   ip);
      vec4 p1 = grad4(j1.x, ip);
      vec4 p2 = grad4(j1.y, ip);
      vec4 p3 = grad4(j1.z, ip);
      vec4 p4 = grad4(j1.w, ip);

    // Normalise gradients
      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
      p0 *= norm.x;
      p1 *= norm.y;
      p2 *= norm.z;
      p3 *= norm.w;
      p4 *= taylorInvSqrt(dot(p4,p4));

    // Mix contributions from the five corners
      vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
      vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);
      m0 = m0 * m0;
      m1 = m1 * m1;
      return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
                   + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;
    }

     varying vec3 vNormal;
     varying float vNoise;
      void main() {
        vUv = uv;
        // 们需要知道将三维空间里的物体显示到二维屏幕上需要通过 MVP 矩阵变换操作，
        // 即 Model 模型矩阵、View 视图矩阵和 Projection 投影矩阵（前俩者可以合并为 modelViewMatrix），
        // 因此在顶点着色器里这一行代码是必不可少的
        // gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(newPos, 1.0);

          vec3 newPos = position;
          float noise = snoise(vec4(position * 10.0, uTime * 0.2));
          // noise = step(0.0, noise);
          newPos += normal * noise * 1.0;
          vNoise = noise;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
          vNormal = normal;
      }
    `;

    // fract实现重复
    // step实现切分
    // clamp(x, min, max) 将 x 值限制到 min-max 之间
    const fragmentShader = /* GLSL */ `
          varying vec2 vUv;
          uniform float uTime;
          varying vec3 vNormal;
          varying float vNoise;

          vec3 rgb(float r, float g, float b){
              return vec3(r,g,b) / 255.;
          }

          float hue2rgb(float f1, float f2, float hue) {
            if (hue < 0.0)
                hue += 1.0;
            else if (hue > 1.0)
                hue -= 1.0;
            float res;
            if ((6.0 * hue) < 1.0)
                res = f1 + (f2 - f1) * 6.0 * hue;
            else if ((2.0 * hue) < 1.0)
                res = f2;
            else if ((3.0 * hue) < 2.0)
                res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;
            else
                res = f1;
            return res;
        }

        vec3 hsl2rgb(vec3 hsl) {
            vec3 rgb;

            if (hsl.y == 0.0) {
                rgb = vec3(hsl.z); // Luminance
            } else {
                float f2;

                if (hsl.z < 0.5)
                    f2 = hsl.z * (1.0 + hsl.y);
                else
                    f2 = hsl.z + hsl.y - hsl.y * hsl.z;

                float f1 = 2.0 * hsl.z - f2;

                rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));
                rgb.g = hue2rgb(f1, f2, hsl.x);
                rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));
            }
            return rgb;
        }

        vec3 hsl2rgb(float h, float s, float l) {
            return hsl2rgb(vec3(h, s, l));
        }

          void main() {
              vec3 color = hsl2rgb(0.07 + vNoise * 0.1, 0.8, 0.5);
              gl_FragColor = vec4(color, 1.0);

          }
`;

    const geometry = new THREE.SphereGeometry(1, 256, 256);
    material = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
        },
        vertexShader,
        fragmentShader,
        // wireframe: true,
    });
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);


    const particleGeometry = new THREE.BufferGeometry(2);

    const N = 4000;
    const positions = new Float32Array(N * 3);

    const inc = Math.PI * (3 - Math.sqrt(5));
    const off = 2 / N;
    const radius = 2;

    for (let i = 0; i < N; i++) {
        const y = i * off - 1 + off / 2;
        const r = Math.sqrt(1 - y * y);
        const phi = i * inc;

        positions[3 * i] = radius * Math.cos(phi) * r;
        positions[3 * i + 1] = radius * y;
        positions[3 * i + 2] = radius * Math.sin(phi) * r;
    }

    particleGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
    );

    const particleVertex = /* GLSL */ `
      uniform float uTime;

      void main() {
         vec3 newPos = position;
         newPos.y += 0.1 * sin(newPos.y * 6.0 + uTime);
         newPos.z += 0.05 * sin(newPos.y * 10.0 + uTime);

        vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
        gl_PointSize = 6.0 / - mvPosition.z;
        gl_Position = projectionMatrix * mvPosition;
      }
`;

    const particleFragment = /* GLSL */ `
  void main() {
    // gl_FragColor = vec4(vec3(1.0), 1.0);
    gl_FragColor = vec4(vec3(1.0), 0.6);
  }
`;

    const particleMaterial = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
        },
        vertexShader: particleVertex,
        fragmentShader: particleFragment,
        transparent: true,
        blending: THREE.AdditiveBlending,
    });
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);

    const firefliesGeometry = new THREE.BufferGeometry();
    const firefliesCount = 300;
    const positions1 = new Float32Array(firefliesCount * 3);
    const sizes = new Float32Array(firefliesCount);

    for (let i = 0; i < firefliesCount; i++) {
        const r = Math.random() * 5 + 5;
        positions1[i * 3] = (Math.random() - 0.5) * r;
        positions1[i * 3 + 1] = (Math.random() - 0.5) * r;
        positions1[i * 3 + 2] = (Math.random() - 0.5) * r;

        sizes[i] = Math.random() + 0.4;
    }

    firefliesGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions1, 3)
    );
    firefliesGeometry.setAttribute("aSize", new THREE.BufferAttribute(sizes, 1));
    const firefliesVertexShader = /* GLSL */ `
    uniform float uTime;
    attribute float aSize;

    void main() {
        vec3 newPos = position;
        newPos.y += sin(uTime * 0.5 + newPos.x * 100.0) * aSize * 0.2;
        newPos.x += sin(uTime * 0.5 + newPos.x * 200.0) * aSize * 0.1;
        vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
        gl_PointSize = 70.0 * aSize / -mvPosition.z;
        gl_Position = projectionMatrix * mvPosition;
    }
`;

    const firefliesFragmentShader = /* GLSL */ `
    void main() {
      float d = length(gl_PointCoord - vec2(0.5));
      float strength = clamp(0.05 / d - 0.05 * 2.0, 0.0, 1.0);
      gl_FragColor = vec4(vec3(1.0), strength);
  }
`;

    const firefliesMaterial = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
        },
        vertexShader: firefliesVertexShader,
        fragmentShader: firefliesFragmentShader,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
    });

    const fireflies = new THREE.Points(firefliesGeometry, firefliesMaterial);
    scene.add(fireflies);



</script>
</html>
