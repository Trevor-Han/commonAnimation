<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title></title>
    <style>
        body { margin: 0; }
    </style>
    <link rel="stylesheet" href="../../css/dat.gui.css">
    <script src="../../3d/dat.gui.js"></script>
</head>
<body>
<canvas id="canvas" class="c2d" width="1000" height="500"></canvas>
</body>
<script type="module">
    import * as THREE from '../../3d/three.module.js';
    import { OrbitControls }  from '../../3d/OrbitControls.js'

    //********************************↓COMMON↓***************************************
    const canvas = document.querySelector('#canvas')
    canvas.height = window.innerHeight
    canvas.width = window.innerWidth

    let scene,camera,renderer,controls

    const fov = 40
    const aspect =  window.innerWidth/  window.innerHeight
    const near = 0.1
    const far = 1000

    scene = new THREE.Scene()
    scene.background = new THREE.Color('#232323')

    camera = new THREE.PerspectiveCamera(fov, aspect, near, far)
    camera.position.set(0, 10, 15)
    camera.lookAt(10,10, 10)

    renderer = new THREE.WebGLRenderer({ canvas,antialias: true })
    renderer.setAnimationLoop(renderLoop);
    renderer.shadowMap.enabled = true;
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize( window.innerWidth, window.innerHeight );

    // 控制相机
    controls = new OrbitControls(camera, canvas)


    window.addEventListener('resize', onWindowResized);

    function onWindowResized() {
        renderer.setSize(window.innerWidth, window.innerHeight);

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

    }

    function renderLoop(){
        let clock = new THREE.Clock();
        material.uniforms.uTime.value = clock.getElapsedTime();
        renderer.render( scene, camera );
    }

    //********************************↑COMMON↑***************************************

    // 顶点坐标 position、纹理坐标 uv、法线向量 normal都是顶点上的数据
    // uniform修饰符->全局变量，在顶点着色器和片元着色器都可以访问（每个顶点或像素数值都相同时变量使用）
    // attribute修饰符->局部变量，只能在顶点着色器中访问(加上，说明明这个数据是每个顶点上都不同的)
    // varying修饰符 -> 用来在顶点着色器和片元着色器之间传递变量的(顶点着色器里的变量想在片元着色器里使用)

    // 不同修饰符对应的变量所采用的命令方式，attribute 的用 a 开头如 aRadom，
    // uniform 的用 u 开头如 uTime，
    // varying 的用 v 开头如 vUv，这是比较直观的一种变量命名方式

    const vertexShader = /* GLSL */ `
      uniform float uTime;
      varying vec2 vUv;

      void main() {
        vUv = uv;
        // 们需要知道将三维空间里的物体显示到二维屏幕上需要通过 MVP 矩阵变换操作，
        // 即 Model 模型矩阵、View 视图矩阵和 Projection 投影矩阵（前俩者可以合并为 modelViewMatrix），
        // 因此在顶点着色器里这一行代码是必不可少的

        // vec4 modelPosition = modelMatrix * vec4(position, 1.0); // 模型位置
        // vec4 viewPosition = viewMatrix * modelPosition; // 视口位置
        // vec4 projectedPosition = projectionMatrix * viewPosition; // 项目位置
        //
        // gl_Position = projectedPosition;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const fragmentShader = /* GLSL */ `
          varying vec2 vUv;

          void main() {
            // 1. 纯红色
            gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);

            // 2. vUv.x => 0.0-1.0 => 左边黑右边红
            gl_FragColor = vec4(vUv.x, 0.0, 0.0, 1.0);

            // 3. vUv.y => 0.0-1.0 => 下边黑上边红
            gl_FragColor = vec4(vUv.y, 0.0, 0.0, 1.0);

            // 4. 黑白灰
            gl_FragColor = vec4(vec3(vUv.x), 1.0);
            gl_FragColor = vec4(vec3(vUv.y), 1.0);

            // 5. 青红、蓝粉
            gl_FragColor = vec4(vUv, 0.0, 1.0);
            gl_FragColor = vec4(vUv, 1.0, 1.0);

            // 6. 颜色突变
            // float color = step(0.5, vUv.x);

            // float color = step(0.3, vUv.x);
            // float color = step(0.7, vUv.x);

            // 7. 黑白突变顺序互换
            // float color = step(0.5, 1.0 - vUv.x);
            // 两种方式都行
            float color = step(vUv.x, 0.5);
            gl_FragColor = vec4(vec3(color), 1.0);

            // 8. 重复条纹效果
            gl_FragColor = vec4(vec3(fract(vUv.x * 3.0)), 1.0);
            gl_FragColor = vec4(vec2(step(0.5, fract(vUv.x * 3.0))),0.1, 1.0);
          }
`;

    // const geometry = new THREE.PlaneGeometry(1, 1);
    // const geometry = new THREE.BoxGeometry(1, 1, 1);
    const geometry = new THREE.SphereGeometry(2, 32, 16);
    // const geometry = new THREE.ConeGeometry(1, 2, 16, 1);

    const material = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
        },
        vertexShader,
        fragmentShader,
        // wireframe: true,
    });

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);


</script>
</html>
